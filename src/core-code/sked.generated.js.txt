/*
 * Copyright (c) 2022-2023 SÃ©bastien Piquemal <sebpiq@protonmail.com>, Chris McCormick.
 *
 * This file is part of WebPd
 * (see https://github.com/sebpiq/WebPd).
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 */
/**
 * Skeduler id that will never be used.
 * Can be used as a "no id", or "null" value.
 */
const SKED_ID_NULL = -1;
const SKED_ID_COUNTER_INIT = 1;
const _SKED_WAIT_IN_PROGRESS = 0;
const _SKED_WAIT_OVER = 1;
const _SKED_MODE_WAIT = 0;
const _SKED_MODE_SUBSCRIBE = 1;
// =========================== SKED API
class SkedRequest {
}
class Skeduler {
}
/** Creates a new Skeduler. */
function sked_create(isLoggingEvents) {
    return {
        eventLog: new Set(),
        requests: new Map(),
        callbacks: new Map(),
        idCounter: SKED_ID_COUNTER_INIT,
        isLoggingEvents,
    };
}
/**
 * Asks the skeduler to wait for an event to occur and trigger a callback.
 * If the event has already occurred, the callback is triggered instantly
 * when calling the function.
 * Once triggered, the callback is forgotten.
 * @returns an id allowing to cancel the callback with {@link sked_cancel}
 */
function sked_wait(skeduler, event, callback) {
    if (skeduler.isLoggingEvents === false) {
        throw new Error("Please activate skeduler's isLoggingEvents");
    }
    if (skeduler.eventLog.has(event)) {
        callback(event);
        return SKED_ID_NULL;
    }
    else {
        return _sked_createRequest(skeduler, event, callback, _SKED_MODE_WAIT);
    }
}
/**
 * Asks the skeduler to wait for an event to occur and trigger a callback.
 * If the event has already occurred, the callback is NOT triggered.
 * Once triggered, the callback is forgotten.
 * @returns an id allowing to cancel the callback with {@link sked_cancel}
 */
function sked_wait_future(skeduler, event, callback) {
    return _sked_createRequest(skeduler, event, callback, _SKED_MODE_WAIT);
}
/**
 * Asks the skeduler to trigger a callback everytime an event occurs
 * @returns an id allowing to cancel the callback with {@link sked_cancel}
 */
function sked_subscribe(skeduler, event, callback) {
    return _sked_createRequest(skeduler, event, callback, _SKED_MODE_SUBSCRIBE);
}
/** Notifies the skeduler that an event has just occurred. */
function sked_emit(skeduler, event) {
    if (skeduler.isLoggingEvents === true) {
        skeduler.eventLog.add(event);
    }
    if (skeduler.requests.has(event)) {
        const requests = skeduler.requests.get(event);
        const requestsStaying = [];
        for (let i = 0; i < requests.length; i++) {
            const request = requests[i];
            if (skeduler.callbacks.has(request.id)) {
                skeduler.callbacks.get(request.id)(event);
                if (request.mode === _SKED_MODE_WAIT) {
                    skeduler.callbacks.delete(request.id);
                }
                else {
                    requestsStaying.push(request);
                }
            }
        }
        skeduler.requests.set(event, requestsStaying);
    }
}
/** Cancels a callback */
function sked_cancel(skeduler, id) {
    skeduler.callbacks.delete(id);
}
// =========================== PRIVATE
function _sked_createRequest(skeduler, event, callback, mode) {
    const id = _sked_nextId(skeduler);
    const request = { id, mode };
    skeduler.callbacks.set(id, callback);
    if (!skeduler.requests.has(event)) {
        skeduler.requests.set(event, [request]);
    }
    else {
        skeduler.requests.get(event).push(request);
    }
    return id;
}
function _sked_nextId(skeduler) {
    return skeduler.idCounter++;
}
