/*
 * Copyright (c) 2012-2020 SÃ©bastien Piquemal <sebpiq@gmail.com>
 *
 * BSD Simplified License.
 * For information on usage and redistribution, and for a DISCLAIMER OF ALL
 * WARRANTIES, see the file, "LICENSE.txt," in this distribution.
 *
 * See https://github.com/sebpiq/WebPd_pd-parser for documentation
 *
 */

type SkedWaitCallback = (eventName: string) => void

const _SKED_WAIT_IN_PROGRESS = 0
const _SKED_WAIT_OVER = 1

// =========================== SKED API

class Skeduler {
    waitStatuses: Map<string, Int>
    waitCallbacks: Map<string, Array<SkedWaitCallback>>
    constructor() {
        this.waitStatuses = new Map()
        this.waitCallbacks = new Map()
    }
}

function sked_create (): Skeduler {
    return new Skeduler()
}

function sked_resolve (
    skeduler: Skeduler,
    event: string,
): void {
    skeduler.waitStatuses.set(event, _SKED_WAIT_OVER)
    if (skeduler.waitCallbacks.has(event)) {
        const handlers: Array<SkedWaitCallback> = skeduler.waitCallbacks.get(event)
        for (let i: Int = 0; i < handlers.length; i++) {
            handlers[i](event)
        }
        skeduler.waitCallbacks.delete(event)
    }
}

function sked_wait (
    skeduler: Skeduler,
    event: string,
    callback: SkedWaitCallback,
): void {
    if (
        skeduler.waitStatuses.has(event)
        && skeduler.waitStatuses.get(event) === _SKED_WAIT_OVER
    ) {
        callback(event)
    } else {
        skeduler.waitStatuses.set(event, _SKED_WAIT_IN_PROGRESS)
        if (!skeduler.waitCallbacks.has(event)) {
            skeduler.waitCallbacks.set(event, [callback])    
        } else {
            skeduler.waitCallbacks.get(event).push(callback)
        }
    }
}
