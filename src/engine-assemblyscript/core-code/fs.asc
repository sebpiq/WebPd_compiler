/*
 * Copyright (c) 2012-2020 SÃ©bastien Piquemal <sebpiq@gmail.com>
 *
 * BSD Simplified License.
 * For information on usage and redistribution, and for a DISCLAIMER OF ALL
 * WARRANTIES, see the file, "LICENSE.txt," in this distribution.
 *
 * See https://github.com/sebpiq/WebPd_pd-parser for documentation
 *
 */

type FileOperationId = i32
type Url = string
type DecodingInfo = ArrayBuffer
type EncodingInfo = ArrayBuffer
type FileOperationStatus = i32

// Max length : about 10s at sample rate 44100
const _FS_SOUND_BUFFER_MAX_LENGTH = 10 * 44100

const _FS_OPERATION_UNKNOWN: FileOperationStatus = -1
const _FS_OPERATION_PROCESSING: FileOperationStatus = 0
const _FS_OPERATION_SUCCESS: FileOperationStatus = 1
const _FS_OPERATION_FAILED: FileOperationStatus = 2

const _FS_OPERATIONS_STATUSES = new Map<FileOperationId, FileOperationStatus>()
const _FS_OPERATIONS_SOUNDS = new Map<FileOperationId, TypedArray[]>()
const _FS_SOUND_STREAM_BUFFERS = new Map<FileOperationId, _fs_SoundBuffer>()

let FILE_OPERATION_COUNTER: i32 = 0

// =========================== PUBLIC API
// These functions are implemented in the host environment
export declare function fs_requestReadSoundFile (id: FileOperationId, url: Url, info: DecodingInfo): void
export declare function fs_requestReadSoundStream (id: FileOperationId, url: Url, info: DecodingInfo): void
export declare function fs_requestWriteSoundFile (id: FileOperationId, url: Url, sound: TypedArray[], info: EncodingInfo): void
export declare function fs_requestCloseSoundStream (id: FileOperationId): void

// These functions are to be called by the host environment to notify the end of the operation
export function fs_readSoundFileResponse (id: FileOperationId, sound: TypedArray[]): void { //, METADATA: i32): void {
    _FS_OPERATIONS_STATUSES.set(id, _FS_OPERATION_SUCCESS)
    _FS_OPERATIONS_SOUNDS.set(id, sound)
}

export function fs_writeSoundFileResponse (id: FileOperationId): void {
    _FS_OPERATIONS_STATUSES.set(id, _FS_OPERATION_SUCCESS)
}

export function fs_soundStreamData (id: FileOperationId, block: TypedArray[]): i32 {
    return 0
}

export function fs_soundStreamClose (id: FileOperationId): void {}

// =========================== INTERNAL API
function fs_readSoundFile(url: Url): FileOperationId {
    const id: FileOperationId = FILE_OPERATION_COUNTER++
    _FS_OPERATIONS_STATUSES.set(id, _FS_OPERATION_PROCESSING)
    fs_requestReadSoundFile(id, url, new ArrayBuffer(0))
    return id
}

function fs_readSoundStream(url: Url): FileOperationId {
    const id: FileOperationId = FILE_OPERATION_COUNTER++
    const buffer = new _fs_SoundBuffer(_FS_SOUND_BUFFER_MAX_LENGTH)
    _FS_OPERATIONS_STATUSES.set(id, _FS_OPERATION_PROCESSING)
    _FS_SOUND_STREAM_BUFFERS.set(id, buffer)
    fs_requestReadSoundStream(id, url, new ArrayBuffer(0))
    return id
}

function fs_writeSoundFile(url: Url, sound: TypedArray[]): FileOperationId {
    const id: FileOperationId = FILE_OPERATION_COUNTER++
    _FS_OPERATIONS_STATUSES.set(id, _FS_OPERATION_PROCESSING)
    fs_requestWriteSoundFile(url, sound, new ArrayBuffer(0))
    return id
}

function fs_checkoutSoundFile(id: FileOperationId): TypedArray[] {
    const sound: TypedArray[] = _FS_OPERATIONS_SOUNDS.get(id)
    _FS_OPERATIONS_SOUNDS.delete(id)
    _FS_OPERATIONS_STATUSES.delete(id)
    return sound
}

function fs_checkOperationStatus(id: FileOperationId): FileOperationStatus {
    if (_FS_OPERATIONS_STATUSES.has(id)) {
        return _FS_OPERATIONS_STATUSES.get(id)
    } else {
        return _FS_OPERATION_UNKNOWN
    }
}

// =========================== PRIVATE
class _fs_SoundBuffer {
    public blocks: TypedArray[][]
    public maxLength: i32

    public currentLength: i32
    public currentBlockCursor: i32
    public currentBlockLength: i32
    public currentBlock: TypedArray[]
    
    constructor(maxLength: i32) {
        // Dummy block that'll get kicked at the first pullFrame
        this.blocks = [[new ${FloatArrayType}(0)]]
        this.maxLength = maxLength

        this.currentLength = 0
        this.currentBlockCursor = 0
        this.currentBlockLength = 0
        this.currentBlock = []
    }

    pushBlock(block: TypedArray[]): i32 {
        const additionalLength = block[0].length
        if (this.currentLength + additionalLength > this.maxLength) {
            throw new Error(`buffer is full`)
        }
        this.blocks.push(block)
        this.currentLength += additionalLength
        // Returns space available
        return this.maxLength - this.currentLength
    }

    availableFrameCount(): i32 {
        return this.currentLength - this.currentBlockCursor
    }

    pullFrame(): TypedArray {
        if (this.currentBlockCursor >= this.currentBlockLength) {
            const discardedBlock = this.blocks.shift()
            this.currentLength -= discardedBlock[0].length

            this.currentBlock = this.blocks[0]
            this.currentBlockLength = this.currentBlock[0].length
            this.currentBlockCursor = 0
        }

        const currentBlockCursor = this.currentBlockCursor++
        const currentBlock = this.currentBlock
        const channelCount = this.currentBlock.length
        const frame: TypedArray = new ${FloatArrayType}(channelCount)
        for (let channel: i32; channel < channelCount; channel++) {
            frame[channel] = currentBlock[channel][currentBlockCursor]
        }
        return frame
    }
}