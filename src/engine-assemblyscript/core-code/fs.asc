/*
 * Copyright (c) 2012-2020 SÃ©bastien Piquemal <sebpiq@gmail.com>
 *
 * BSD Simplified License.
 * For information on usage and redistribution, and for a DISCLAIMER OF ALL
 * WARRANTIES, see the file, "LICENSE.txt," in this distribution.
 *
 * See https://github.com/sebpiq/WebPd_pd-parser for documentation
 *
 */

const FS_OPERATION_SUCCESS: Int = ${FS_OPERATION_SUCCESS}
const FS_OPERATION_FAILURE: Int = ${FS_OPERATION_FAILURE}

type fs_OperationId = Int
type fs_OperationStatus = Int
type fs_OperationCallback = (id: fs_OperationId, status: fs_OperationStatus) => void
type fs_OperationSoundCallback = (id: fs_OperationId, status: fs_OperationStatus, sound: FloatArray[]) => void

type Url = string
type DecodingInfo = ArrayBuffer
type EncodingInfo = ArrayBuffer

// Max length : about 10s at sample rate 44100
const _FS_SOUND_BUFFER_MAX_LENGTH = 10 * 44100

const _FS_OPERATIONS_IDS = new Set<fs_OperationId>()
const _FS_OPERATIONS_CALLBACKS = new Map<fs_OperationId, fs_OperationCallback>()
const _FS_OPERATIONS_SOUND_CALLBACKS = new Map<fs_OperationId, fs_OperationSoundCallback>()
const _FS_SOUND_STREAM_BUFFERS = new Map<fs_OperationId, _fs_SoundBuffer>()

let FILE_OPERATION_COUNTER: Int = 0

// =========================== EXPORTED API
function x_fs_readSoundFileResponse (
    id: fs_OperationId, 
    status: fs_OperationStatus, 
    sound: FloatArray[]
): void {
    if (!_FS_OPERATIONS_IDS.has(id)) {
        return
    }
    _FS_OPERATIONS_IDS.delete(id)
    _FS_OPERATIONS_SOUND_CALLBACKS.get(id)(id, status, sound)
    _FS_OPERATIONS_SOUND_CALLBACKS.delete(id)
}

function x_fs_writeSoundFileResponse (id: fs_OperationId): void {
    _FS_OPERATIONS_IDS.delete(id)
}

function x_fs_soundStreamData (id: fs_OperationId, block: FloatArray[]): Int {
    if (!_FS_OPERATIONS_IDS.has(id)) {
        return -1
    }
    const buffer: _fs_SoundBuffer = _FS_SOUND_STREAM_BUFFERS.get(id)
    return buffer.pushBlock(block)
}

function x_fs_soundStreamClose (id: fs_OperationId): void {
    if (!_FS_OPERATIONS_IDS.has(id)) {
        return
    }
    _FS_OPERATIONS_IDS.delete(id)
    const callback: fs_OperationCallback = _FS_OPERATIONS_CALLBACKS.get(id)
    callback(id, FS_OPERATION_SUCCESS)
    fs_requestCloseSoundStream(id)
}


// =========================== FS API
function fs_readSoundFile(url: Url, callback: fs_OperationSoundCallback): fs_OperationId {
    const id: fs_OperationId = FILE_OPERATION_COUNTER++
    _FS_OPERATIONS_IDS.add(id)
    _FS_OPERATIONS_SOUND_CALLBACKS.set(id, callback)
    fs_requestReadSoundFile(id, url, new ArrayBuffer(0))
    return id
}

function fs_readSoundStream(url: Url, callback: fs_OperationCallback): fs_OperationId {
    const id: fs_OperationId = FILE_OPERATION_COUNTER++
    const buffer = new _fs_SoundBuffer(_FS_SOUND_BUFFER_MAX_LENGTH)
    _FS_OPERATIONS_IDS.add(id)
    _FS_SOUND_STREAM_BUFFERS.set(id, buffer)
    _FS_OPERATIONS_CALLBACKS.set(id, callback)
    fs_requestReadSoundStream(id, url, new ArrayBuffer(0))
    return id
}

function fs_writeSoundFile(url: Url, sound: FloatArray[]): fs_OperationId {
    const id: fs_OperationId = FILE_OPERATION_COUNTER++
    _FS_OPERATIONS_IDS.add(id)
    fs_requestWriteSoundFile(url, sound, new ArrayBuffer(0))
    return id
}

// =========================== PRIVATE
class _fs_SoundBuffer {
    public blocks: FloatArray[][]
    public maxLength: Int

    public currentLength: Int
    public currentBlockCursor: Int
    public currentBlockLength: Int
    public currentBlock: FloatArray[]
    
    constructor(maxLength: Int) {
        // Dummy block that'll get kicked at the first pullFrame
        this.blocks = [[new ${FloatArray}(0)]]
        this.maxLength = maxLength

        this.currentLength = 0
        this.currentBlockCursor = 0
        this.currentBlockLength = 0
        this.currentBlock = []
    }

    pushBlock(block: FloatArray[]): Int {
        const additionalLength = block[0].length
        if (this.currentLength + additionalLength > this.maxLength) {
            throw new Error(`buffer is full`)
        }
        this.blocks.push(block)
        this.currentLength += additionalLength
        // Returns space available
        return this.maxLength - this.currentLength
    }

    availableFrameCount(): Int {
        return this.currentLength - this.currentBlockCursor
    }

    pullFrame(): FloatArray {
        if (this.currentBlockCursor >= this.currentBlockLength) {
            const discardedBlock = this.blocks.shift()
            this.currentLength -= discardedBlock[0].length

            this.currentBlock = this.blocks[0]
            this.currentBlockLength = this.currentBlock[0].length
            this.currentBlockCursor = 0
        }

        const currentBlockCursor = this.currentBlockCursor++
        const currentBlock = this.currentBlock
        const channelCount = this.currentBlock.length
        const frame: FloatArray = new ${FloatArray}(channelCount)
        for (let channel: Int = 0; channel < channelCount; channel++) {
            frame[channel] = currentBlock[channel][currentBlockCursor]
        }
        return frame
    }
}