/*
 * Copyright (c) 2012-2020 SÃ©bastien Piquemal <sebpiq@gmail.com>
 *
 * BSD Simplified License.
 * For information on usage and redistribution, and for a DISCLAIMER OF ALL
 * WARRANTIES, see the file, "LICENSE.txt," in this distribution.
 *
 * See https://github.com/sebpiq/WebPd_pd-parser for documentation
 *
 */

const FS_OPERATION_SUCCESS: Int = ${FS_OPERATION_SUCCESS}
const FS_OPERATION_FAILURE: Int = ${FS_OPERATION_FAILURE}

type fs_OperationId = Int
type fs_OperationStatus = Int
type fs_OperationCallback = (id: fs_OperationId, status: fs_OperationStatus) => void
type fs_OperationSoundCallback = (id: fs_OperationId, status: fs_OperationStatus, sound: FloatArray[]) => void

type Url = string

const _FS_OPERATIONS_IDS = new Set<fs_OperationId>()
const _FS_OPERATIONS_CALLBACKS = new Map<fs_OperationId, fs_OperationCallback>()
const _FS_OPERATIONS_SOUND_CALLBACKS = new Map<fs_OperationId, fs_OperationSoundCallback>()
const _FS_SOUND_STREAM_BUFFERS = new Map<fs_OperationId, _fs_SoundBuffer>()

let _FS_OPERATION_COUNTER: Int = 0


// =========================== EXPORTED API
function x_fs_onReadSoundFileResponse (
    id: fs_OperationId, 
    status: fs_OperationStatus,
    sound: FloatArray[]
): void {
    if (!_FS_OPERATIONS_IDS.has(id)) {
        throw new Error(`fs_sendReadSoundFileResponse operation unknown : "${id}"`)
    }
    _FS_OPERATIONS_IDS.delete(id)
    // Finish cleaning before calling the callback in case it would throw an error.
    const callback = _FS_OPERATIONS_SOUND_CALLBACKS.get(id)
    callback(id, status, sound)
    _FS_OPERATIONS_SOUND_CALLBACKS.delete(id)
}

function x_fs_onWriteSoundFileResponse (
    id: fs_OperationId,
    status: fs_OperationStatus,
): void {
    if (!_FS_OPERATIONS_IDS.has(id)) {
        throw new Error(`fs_sendWriteSoundFileResponse operation unknown : "${id}"`)
    }
    _FS_OPERATIONS_IDS.delete(id)
    // Finish cleaning before calling the callback in case it would throw an error.
    const callback = _FS_OPERATIONS_CALLBACKS.get(id)
    callback(id, status)
    _FS_OPERATIONS_CALLBACKS.delete(id)
}

function x_fs_onSoundStreamData (id: fs_OperationId, block: FloatArray[]): Int {
    if (!_FS_OPERATIONS_IDS.has(id)) {
        throw new Error(`fs_sendSoundStreamData operation unknown : "${id}"`)
    }
    return _FS_SOUND_STREAM_BUFFERS.get(id).pushBlock(block)
}

function x_fs_onCloseSoundStream (
    id: fs_OperationId, 
    status: fs_OperationStatus
): void {
    fs_closeSoundStream(id, status)
}


// =========================== FS API
function fs_readSoundFile(
    url: Url,
    info: Message,
    callback: fs_OperationSoundCallback
): fs_OperationId {
    const id: fs_OperationId = _fs_createOperationId()
    _FS_OPERATIONS_SOUND_CALLBACKS.set(id, callback)
    i_fs_readSoundFile(id, url, info)
    return id
}

function fs_writeSoundFile(
    sound: FloatArray[],
    url: Url,
    info: Message,
    callback: fs_OperationCallback,
): fs_OperationId {
    const id: fs_OperationId = _fs_createOperationId()
    _FS_OPERATIONS_CALLBACKS.set(id, callback)
    i_fs_writeSoundFile(id, sound, url, info)
    return id
}

function fs_openSoundReadStream(
    url: Url, 
    info: Message,
    callback: fs_OperationCallback,
): fs_OperationId {
    const id: fs_OperationId = _fs_createOperationId()
    const channelCount: Int = ${Int}(msg_readFloatToken(info, 0))
    const buffer = new _fs_SoundBuffer(channelCount)
    _FS_SOUND_STREAM_BUFFERS.set(id, buffer)
    _FS_OPERATIONS_CALLBACKS.set(id, callback)
    i_fs_openSoundReadStream(id, url, info)
    return id
}

function fs_openSoundWriteStream(
    url: Url, 
    info: Message,
    callback: fs_OperationCallback,
): fs_OperationId {
    const id: fs_OperationId = _fs_createOperationId()
    const channelCount: Int = ${Int}(msg_readFloatToken(info, 0))
    const buffer = new _fs_SoundBuffer(channelCount)
    _FS_SOUND_STREAM_BUFFERS.set(id, buffer)
    _FS_OPERATIONS_CALLBACKS.set(id, callback)
    i_fs_openSoundWriteStream(id, url, info)
    return id
}

function fs_closeSoundStream (
    id: fs_OperationId, 
    status: fs_OperationStatus
): void {
    if (!_FS_OPERATIONS_IDS.has(id)) {
        return
    }
    _FS_OPERATIONS_IDS.delete(id)
    _FS_OPERATIONS_CALLBACKS.get(id)(id, status)
    _FS_OPERATIONS_CALLBACKS.delete(id)
    // Delete this last, to give the callback a chance to save a reference to the buffer
    _FS_SOUND_STREAM_BUFFERS.delete(id)
    i_fs_closeSoundStream(id, status)
}

// Structure : [channelCount]
function fs_soundInfo(channelCount: Int): Message {
    const info: Message = msg_create([MSG_FLOAT_TOKEN])
    msg_writeFloatToken(info, 0, ${Float}(channelCount))
    return info
}

// =========================== PRIVATE
// TODO : Optimize by flattening frames + ring buffer (allows to read/write directly from host)
class _fs_SoundBuffer {
    public blocks: FloatArray[][]
    public channelCount: Int

    // Current block being read
    private currentBlockCursor: Int
    private currentBlockLength: Int
    private currentBlock: FloatArray[]
    // Current total length of data held by the buffer, 
    // including frames that have already been read and discarded
    private currentLength: Int

    private readonly voidBlock: FloatArray[]
    private readonly frameArray: FloatArray
    
    constructor(channelCount: Int) {
        this.voidBlock = [new ${FloatArray}(0)]
        this.frameArray = new ${FloatArray}(channelCount)
        this.channelCount = channelCount

        this.currentLength = 0
        this.blocks = []
        this.currentBlock = []

        this._loadCurrentBlock(this.voidBlock)
    }

    pushBlock(block: FloatArray[]): Int {
        this.currentLength += block[0].length
        
        if (!this._hasCurrentBlock()) {
            this._loadCurrentBlock(block)
        } else {
            this.blocks.push(block)
        }
        return this.availableFrameCount()
    }

    availableFrameCount(): Int {
        return this.currentLength - this.currentBlockCursor
    }

    pullFrame(): FloatArray {
        if (this.currentBlockCursor >= this.currentBlockLength) {
            // Discard current block and load next one
            if (this._hasCurrentBlock()) {
                this.currentLength -= this.currentBlock[0].length
                if (this.blocks.length !== 0) {
                    this._loadCurrentBlock(this.blocks.shift())
                } else {
                    this._resetFrameArray()
                    this._loadCurrentBlock(this.voidBlock)
                }
            }
            
            if (!this._hasCurrentBlock()) {
                return this.frameArray
            }
        }

        const currentBlockCursor = this.currentBlockCursor++
        const currentBlock = this.currentBlock
        for (let channel: Int = 0; channel < this.channelCount; channel++) {
            this.frameArray[channel] = currentBlock[channel][currentBlockCursor]
        }
        return this.frameArray
    }

    getCurrentBlock(): FloatArray[] {
        return this.currentBlock
    }

    _loadCurrentBlock(block: FloatArray[]): void {
        this.currentBlock = block
        this.currentBlockLength = block[0].length
        this.currentBlockCursor = 0
    }

    _hasCurrentBlock(): boolean {
        return this.currentBlock[0].length !== 0
    }

    _resetFrameArray(): void {
        for (let channel: Int = 0; channel < this.channelCount; channel++) {
            this.frameArray[channel] = 0
        }
    }
}

function _fs_createOperationId(): fs_OperationId {
    const id: fs_OperationId = _FS_OPERATION_COUNTER++
    _FS_OPERATIONS_IDS.add(id)
    return id
}