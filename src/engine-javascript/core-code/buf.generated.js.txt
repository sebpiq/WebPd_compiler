/*
 * Copyright (c) 2012-2020 SÃ©bastien Piquemal <sebpiq@gmail.com>
 *
 * BSD Simplified License.
 * For information on usage and redistribution, and for a DISCLAIMER OF ALL
 * WARRANTIES, see the file, "LICENSE.txt," in this distribution.
 *
 * See https://github.com/sebpiq/WebPd_pd-parser for documentation
 *
 */
// =========================== BUF API
class buf_SoundBuffer {
    constructor(length) {
        this.length = length;
        this.data = new ${FloatArray}(length);
        this.writeCursor = 0;
        this.pullAvailableLength = 0;
    }
}
// TODO : Optimize by allowing to read/write directly from host
function buf_pushBlock(buffer, block) {
    if (buffer.pullAvailableLength + block.length > buffer.length) {
        throw new Error('buffer full');
    }
    let left = block.length;
    while (left > 0) {
        const lengthToWrite = toInt(Math.min(toFloat(buffer.length - buffer.writeCursor), toFloat(left)));
        buffer.data.set(block.subarray(block.length - left, block.length - left + lengthToWrite), buffer.writeCursor);
        left -= lengthToWrite;
        buffer.writeCursor = (buffer.writeCursor + lengthToWrite) % buffer.length;
        buffer.pullAvailableLength += lengthToWrite;
    }
    return buffer.pullAvailableLength;
}
function buf_pullSample(buffer) {
    if (buffer.pullAvailableLength <= 0) {
        throw new Error('buffer empty');
    }
    let readCursor = buffer.writeCursor - buffer.pullAvailableLength;
    if (readCursor < 0) {
        readCursor = buffer.length + readCursor;
    }
    buffer.pullAvailableLength -= 1;
    return buffer.data[readCursor];
}
