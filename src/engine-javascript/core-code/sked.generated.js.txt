/*
 * Copyright (c) 2012-2020 SÃ©bastien Piquemal <sebpiq@gmail.com>
 *
 * BSD Simplified License.
 * For information on usage and redistribution, and for a DISCLAIMER OF ALL
 * WARRANTIES, see the file, "LICENSE.txt," in this distribution.
 *
 * See https://github.com/sebpiq/WebPd_pd-parser for documentation
 *
 */
/**
 * Skeduler id that will never be used.
 * Can be used as a "no id", or "null" value.
 */
const SKED_ID_NULL = -1;
const SKED_ID_COUNTER_INIT = 1;
const _SKED_WAIT_IN_PROGRESS = 0;
const _SKED_WAIT_OVER = 1;
const _SKED_MODE_WAIT = 0;
const _SKED_MODE_SUBSCRIBE = 1;
// =========================== SKED API
class SkedRequest {
}
class Skeduler {
}
/** Creates a new Skeduler. */
function sked_create(isLoggingEvents) {
    return {
        eventLog: new Set(),
        requests: new Map(),
        callbacks: new Map(),
        idCounter: SKED_ID_COUNTER_INIT,
        isLoggingEvents,
    };
}
/**
 * Asks the skeduler to wait for an event to occur and trigger a callback.
 * If the event has already occurred, the callback is triggered instantly
 * when calling the function.
 * Once triggered, the callback is forgotten.
 * @returns an id allowing to cancel the callback with {@link sked_cancel}
 */
function sked_wait(skeduler, event, callback) {
    if (skeduler.isLoggingEvents === false) {
        throw new Error("Please activate skeduler's isLoggingEvents");
    }
    if (skeduler.eventLog.has(event)) {
        callback(event);
        return SKED_ID_NULL;
    }
    else {
        return _sked_createRequest(skeduler, event, callback, _SKED_MODE_WAIT);
    }
}
/**
 * Asks the skeduler to wait for an event to occur and trigger a callback.
 * If the event has already occurred, the callback is NOT triggered.
 * Once triggered, the callback is forgotten.
 * @returns an id allowing to cancel the callback with {@link sked_cancel}
 */
function sked_wait_future(skeduler, event, callback) {
    return _sked_createRequest(skeduler, event, callback, _SKED_MODE_WAIT);
}
/**
 * Asks the skeduler to trigger a callback everytime an event occurs
 * @returns an id allowing to cancel the callback with {@link sked_cancel}
 */
function sked_subscribe(skeduler, event, callback) {
    return _sked_createRequest(skeduler, event, callback, _SKED_MODE_SUBSCRIBE);
}
/** Notifies the skeduler that an event has just occurred. */
function sked_emit(skeduler, event) {
    if (skeduler.isLoggingEvents === true) {
        skeduler.eventLog.add(event);
    }
    if (skeduler.requests.has(event)) {
        const requests = skeduler.requests.get(event);
        const requestsStaying = [];
        for (let i = 0; i < requests.length; i++) {
            const request = requests[i];
            if (skeduler.callbacks.has(request.id)) {
                skeduler.callbacks.get(request.id)(event);
                if (request.mode === _SKED_MODE_WAIT) {
                    skeduler.callbacks.delete(request.id);
                }
                else {
                    requestsStaying.push(request);
                }
            }
        }
        skeduler.requests.set(event, requestsStaying);
    }
}
/** Cancels a callback */
function sked_cancel(skeduler, id) {
    skeduler.callbacks.delete(id);
}
// =========================== PRIVATE
function _sked_createRequest(skeduler, event, callback, mode) {
    const id = _sked_nextId(skeduler);
    const request = { id, mode };
    skeduler.callbacks.set(id, callback);
    if (!skeduler.requests.has(event)) {
        skeduler.requests.set(event, [request]);
    }
    else {
        skeduler.requests.get(event).push(request);
    }
    return id;
}
function _sked_nextId(skeduler) {
    return skeduler.idCounter++;
}
