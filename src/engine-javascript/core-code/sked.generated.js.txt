/*
 * Copyright (c) 2012-2020 SÃ©bastien Piquemal <sebpiq@gmail.com>
 *
 * BSD Simplified License.
 * For information on usage and redistribution, and for a DISCLAIMER OF ALL
 * WARRANTIES, see the file, "LICENSE.txt," in this distribution.
 *
 * See https://github.com/sebpiq/WebPd_pd-parser for documentation
 *
 */
/**
 * Skeduler id that will never be used.
 * Can be used as a "no id", or "null" value.
 */
const SKED_ID_NULL = -1;
const _SKED_WAIT_IN_PROGRESS = 0;
const _SKED_WAIT_OVER = 1;
const _SKED_MODE_WAIT = 0;
const _SKED_MODE_SUBSCRIBE = 1;
// =========================== SKED API
class SkedRequest {
}
class Skeduler {
    constructor() {
        this.eventLog = new Set();
        this.requests = new Map();
        this.callbacks = new Map();
        this.idCounter = 1;
        this.isLoggingEvents = false;
    }
}
function sked_create(isLoggingEvents) {
    const skeduler = new Skeduler();
    skeduler.isLoggingEvents = isLoggingEvents;
    return skeduler;
}
function sked_wait(skeduler, event, callback) {
    if (skeduler.isLoggingEvents === false) {
        throw new Error("Please activate skeduler's isLoggingEvents");
    }
    if (skeduler.eventLog.has(event)) {
        callback(event);
        return SKED_ID_NULL;
    }
    else {
        return _sked_createRequest(skeduler, event, callback, _SKED_MODE_WAIT);
    }
}
function sked_subscribe(skeduler, event, callback) {
    return _sked_createRequest(skeduler, event, callback, _SKED_MODE_SUBSCRIBE);
}
function sked_emit(skeduler, event) {
    if (skeduler.isLoggingEvents === true) {
        skeduler.eventLog.add(event);
    }
    if (skeduler.requests.has(event)) {
        const requests = skeduler.requests.get(event);
        const requestsStaying = [];
        for (let i = 0; i < requests.length; i++) {
            const request = requests[i];
            if (skeduler.callbacks.has(request.id)) {
                skeduler.callbacks.get(request.id)(event);
                if (request.mode === _SKED_MODE_WAIT) {
                    skeduler.callbacks.delete(request.id);
                }
                else {
                    requestsStaying.push(request);
                }
            }
        }
        skeduler.requests.set(event, requestsStaying);
    }
}
function sked_cancel(skeduler, id) {
    skeduler.callbacks.delete(id);
}
function _sked_createRequest(skeduler, event, callback, mode) {
    const id = _sked_nextId(skeduler);
    const request = { id, mode };
    skeduler.callbacks.set(id, callback);
    if (!skeduler.requests.has(event)) {
        skeduler.requests.set(event, [request]);
    }
    else {
        skeduler.requests.get(event).push(request);
    }
    return id;
}
function _sked_nextId(skeduler) {
    return skeduler.idCounter++;
}
