/*
 * Copyright (c) 2012-2020 SÃ©bastien Piquemal <sebpiq@gmail.com>
 *
 * BSD Simplified License.
 * For information on usage and redistribution, and for a DISCLAIMER OF ALL
 * WARRANTIES, see the file, "LICENSE.txt," in this distribution.
 *
 * See https://github.com/sebpiq/WebPd_pd-parser for documentation
 *
 */
const _FS_OPERATIONS_IDS = new Set();
const _FS_OPERATIONS_CALLBACKS = new Map();
const _FS_OPERATIONS_SOUND_CALLBACKS = new Map();
const _FS_SOUND_STREAM_BUFFERS = new Map();
// We start at 1, because 0 is what ASC uses when host forgets to pass an arg to 
// a function. Therefore we can get false negatives when a test happens to expect a 0.
let _FS_OPERATION_COUNTER = 1;
const _FS_SOUND_BUFFER_LENGTH = 20 * 44100;
// =========================== EXPORTED API
function x_fs_onReadSoundFileResponse(id, status, sound) {
    _fs_assertOperationExists(id, 'x_fs_onReadSoundFileResponse');
    _FS_OPERATIONS_IDS.delete(id);
    // Finish cleaning before calling the callback in case it would throw an error.
    const callback = _FS_OPERATIONS_SOUND_CALLBACKS.get(id);
    callback(id, status, sound);
    _FS_OPERATIONS_SOUND_CALLBACKS.delete(id);
}
function x_fs_onWriteSoundFileResponse(id, status) {
    _fs_assertOperationExists(id, 'x_fs_onWriteSoundFileResponse');
    _FS_OPERATIONS_IDS.delete(id);
    // Finish cleaning before calling the callback in case it would throw an error.
    const callback = _FS_OPERATIONS_CALLBACKS.get(id);
    callback(id, status);
    _FS_OPERATIONS_CALLBACKS.delete(id);
}
function x_fs_onSoundStreamData(id, block) {
    _fs_assertOperationExists(id, 'x_fs_onSoundStreamData');
    const buffers = _FS_SOUND_STREAM_BUFFERS.get(id);
    for (let i = 0; i < buffers.length; i++) {
        buf_pushBlock(buffers[i], block[i]);
    }
    return buffers[0].pullAvailableLength;
}
function x_fs_onCloseSoundStream(id, status) {
    fs_closeSoundStream(id, status);
}
// =========================== FS API
class fs_SoundInfo {
}
function fs_readSoundFile(url, soundInfo, callback) {
    const id = _fs_createOperationId();
    _FS_OPERATIONS_SOUND_CALLBACKS.set(id, callback);
    i_fs_readSoundFile(id, url, fs_soundInfoToMessage(soundInfo));
    return id;
}
function fs_writeSoundFile(sound, url, soundInfo, callback) {
    const id = _fs_createOperationId();
    _FS_OPERATIONS_CALLBACKS.set(id, callback);
    i_fs_writeSoundFile(id, sound, url, fs_soundInfoToMessage(soundInfo));
    return id;
}
function fs_openSoundReadStream(url, soundInfo, callback) {
    const id = _fs_createOperationId();
    const buffers = [];
    for (let channel = 0; channel < soundInfo.channelCount; channel++) {
        buffers.push(new buf_SoundBuffer(_FS_SOUND_BUFFER_LENGTH));
    }
    _FS_SOUND_STREAM_BUFFERS.set(id, buffers);
    _FS_OPERATIONS_CALLBACKS.set(id, callback);
    i_fs_openSoundReadStream(id, url, fs_soundInfoToMessage(soundInfo));
    return id;
}
function fs_openSoundWriteStream(url, soundInfo, callback) {
    const id = _fs_createOperationId();
    _FS_SOUND_STREAM_BUFFERS.set(id, []);
    _FS_OPERATIONS_CALLBACKS.set(id, callback);
    i_fs_openSoundWriteStream(id, url, fs_soundInfoToMessage(soundInfo));
    return id;
}
function fs_sendSoundStreamData(id, block) {
    _fs_assertOperationExists(id, 'fs_sendSoundStreamData');
    i_fs_sendSoundStreamData(id, block);
}
function fs_closeSoundStream(id, status) {
    if (!_FS_OPERATIONS_IDS.has(id)) {
        return;
    }
    _FS_OPERATIONS_IDS.delete(id);
    _FS_OPERATIONS_CALLBACKS.get(id)(id, status);
    _FS_OPERATIONS_CALLBACKS.delete(id);
    // Delete this last, to give the callback 
    // a chance to save a reference to the buffer
    // If write stream, there won't be a buffer
    if (_FS_SOUND_STREAM_BUFFERS.has(id)) {
        _FS_SOUND_STREAM_BUFFERS.delete(id);
    }
    i_fs_closeSoundStream(id, status);
}
function fs_soundInfoToMessage(soundInfo) {
    const info = msg_create([
        MSG_FLOAT_TOKEN,
        MSG_FLOAT_TOKEN,
        MSG_FLOAT_TOKEN,
        MSG_STRING_TOKEN,
        soundInfo.encodingFormat.length,
        MSG_STRING_TOKEN,
        soundInfo.endianness.length,
        MSG_STRING_TOKEN,
        soundInfo.extraOptions.length
    ]);
    msg_writeFloatToken(info, 0, toFloat(soundInfo.channelCount));
    msg_writeFloatToken(info, 1, toFloat(soundInfo.sampleRate));
    msg_writeFloatToken(info, 2, toFloat(soundInfo.bitDepth));
    msg_writeStringToken(info, 3, soundInfo.encodingFormat);
    msg_writeStringToken(info, 4, soundInfo.endianness);
    msg_writeStringToken(info, 5, soundInfo.extraOptions);
    return info;
}
// =========================== PRIVATE
function _fs_createOperationId() {
    const id = _FS_OPERATION_COUNTER++;
    _FS_OPERATIONS_IDS.add(id);
    return id;
}
function _fs_assertOperationExists(id, operationName) {
    if (!_FS_OPERATIONS_IDS.has(id)) {
        throw new Error(operationName + ' operation unknown : ' + id.toString());
    }
}
